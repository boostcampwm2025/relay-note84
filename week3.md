# Week3

## 지난주 퀘스트 보고 분석 하기
1. 코딩 컨벤션 맞추기 
- 팀 내 서로 다른 스타일을 AI가 객관적으로 중재하는 역할을 수행해, 갈등이나 의견 충돌을 줄이고 합리적 타협점을 도출하는 데 도움을 준다.  
- AI가 스타일에 대한 이유나 근거를 설명해 주면, 단순 자동화가 아닌 학습과 합의 과정으로 이어질 수 있다.  
- 개발자들이 각자 익숙한 스타일에서 벗어나 새로운 방식을 받아들이는 데 심리적 허들을 낮출 수 있다.

2. 커밋 메시지 추천받기
- AI의 자연어 처리 능력을 활용해 명확하고 일관된 커밋 메시지를 만들도록 도와, 협업 시 의사소통 효율이 크게 개선될 수 있다.  
- 커밋 메시지 작성의 부담을 줄이고, 특히 초보 개발자에게 좋은 학습 도구가 된다.  
- 반복적인 사용을 통해 개발자 본인의 메시지 작성 능력 향상과 일관성 유지에 기여한다.

3. 스크럼 자료 요약
- 음성 인식과 요약 기능을 결합하여 회의록 작성에 드는 시간을 대폭 줄여준다.  
- 반복되는 스크럼 회의의 핵심 내용을 빠르게 파악하고 공유하는 데 유용하다.  
- 비대면이나 원격 협업 환경에서 커뮤니케이션 격차를 줄이는 효과가 기대된다.

4. 코드 리뷰 가이드라인 설정
- AI가 명확한 리뷰 기준을 제시함으로써, 리뷰어가 주관적 판단에서 벗어나 일관된 피드백을 제공하도록 돕는다.  
- 리뷰 경험이 적은 개발자에게는 교육적 가이드 역할을 하여 리뷰 역량 향상에 기여한다.  
- 미션 주제에 따른 맞춤형 리뷰 기준 설정이 가능해 상황별 유연한 대응이 가능하다.

## 토론 이야기
우리 팀은 AI를 활용해 코딩 스타일을 맞추는 부분에 대해 이야기를 나눴다. 각자 스타일이 다르다 보니 의견이 갈릴 때가 많았고, 이럴 때 AI가 중립적인 중재자 역할을 해주면 좋겠다는 의견이 나왔다. AI가 스타일을 추천할 때 왜 그런 방식을 택하는지 이유도 함께 설명해주면, 단순한 자동화가 아니라 서로 배우고 합의하는 과정이 될 수 있겠다는 이야기였다.

커밋 메시지 추천 기능에 대해서는 실질적으로 가장 도움이 될 거라는 의견이 많았다. 커밋 메시지는 단순 기록처럼 보이지만, 시간이 지나면 작업 내용을 빠르게 떠올리는 데 중요한 역할을 하는데, 제대로 작성하기 어렵다는 공감대가 형성되었다. 그래서 AI가 명확하고 일관된 메시지를 추천해주면 초보 개발자뿐만 아니라 모두에게 유용할 거라는 이야기가 나왔다. 이러한 대화 끝에, 커밋 메시지 작성 습관을 꾸준히 개선할 수 있도록 AI 추천을 활용하는 퀘스트를 내게 되었다.

또한, 스크럼 회의 내용을 AI가 음성 인식과 요약 기능으로 간단하게 정리해주면 회의록 작성 시간을 크게 줄일 수 있다는 이야기가 있었다. 특히 원격 근무 환경에서 소통이 원활하지 않은 문제를 해결하는 데 도움이 될 것이라는 기대도 컸다.

코드 리뷰 가이드라인에 대해선, AI가 명확하고 일관된 기준을 제시해 주면 리뷰어가 주관적인 판단에서 벗어나 좀 더 객관적인 피드백을 줄 수 있을 거라는 이야기가 나왔다. 리뷰 경험이 적은 개발자에게는 교육적인 도움이 될 수 있다는 점도 강조되었다.

이처럼 다양한 이야기를 나눈 결과, 이전 퀘스트에서는 커밋 메시지 추천 기능을 포함한 새로운 퀘스트를 만들어서 단순히 AI 기능을 시험해보는 데 그치지 않고, 개발자들이 AI를 자연스럽게 업무에 녹여내며, AI가 단순한 도구를 넘어, 함께 성장하는 동반자가 되게끔 하는 퀘스트를 작성 하였다.

### 토론을 해서 나온 후기
퀘스트 중에서 커밋 메시지를 AI로부터 추천받는 미션이 가장 실질적인 도움이 될 것이라고 느꼈다.
커밋 메시지는 단순한 기록이 아니라, 나중에 작업 내용을 빠르게 파악하거나 디버깅할 때 매우 중요한 정보가 된다.
특히 시간이 지나면 **"내가 왜 이 작업을 했지?"** 라는 기억이 흐릿해지기 때문에,
명확하고 일관된 커밋 메시지를 남기는 습관은 개인 생산성뿐 아니라 협업 효율에도 직접적인 영향을 준다.

그런 점에서 이 퀘스트는 단발성으로 끝내기보다,
다음 주에도 이어서 진행하면서 커밋 메시지 작성 습관을 점검하고,
AI를 통해 개선 포인트를 계속 찾아보는 방향으로 이어가고 싶다.

## 넘길 퀘스트
1. 커밋메시지 리뷰 받고 추천 받아서 수정하기
2. ai가 추천하는 함수명, 변수명 받기
3. 건강 관련 도움이 되는 조언 받기
4. 번아웃 예방 동기부여가 되는 멘트 받기

# Week3 퀘스트 목록

## 퀘스트 1: 커밋 메시지, AI에게 리뷰받고 수정하기

### 배경
커밋 메시지는 코드의 맥락과 의도를 전달하는 중요한 기록입니다. 하지만 종종 너무 간단하거나 모호하게 작성되기도 합니다. AI에게 커밋 메시지를 리뷰받고 추천을 받아 수정하면, 더 명확하고 일관된 메시지를 작성하는 습관을 들일 수 있습니다.

### 목적
- 커밋 메시지의 명확성과 일관성을 높인다.
- AI의 추천을 통해 더 나은 표현을 학습한다.

### 달성 기준
- 커밋 메시지를 AI에게 보여주고 리뷰를 요청한다.
- "더 나은 커밋 메시지를 추천해줘"라고 요청한다.
- 추천 메시지 중 하나를 선택하거나 수정하여 최종 메시지를 작성한다.
- **주 4회 이상 실천하면 퀘스트 달성!**

---

## 퀘스트 2: 함수명과 변수명, AI에게 추천받기

### 배경
함수명과 변수명은 코드의 가독성과 유지보수성을 좌우합니다. 하지만 이름 짓기는 늘 어렵고, 고민이 길어지기 마련입니다. AI에게 추천을 받으면 더 직관적이고 일관된 이름을 빠르게 결정할 수 있습니다.

### 목적
- 의미 있는 이름을 빠르게 결정한다.
- AI의 추천을 통해 네이밍 감각을 키운다.

### 달성 기준
- 함수 또는 변수의 역할을 AI에게 설명한다.
- "이 역할에 어울리는 함수명/변수명을 추천해줘"라고 요청한다.
- 추천된 이름 중 하나를 선택하거나 수정하여 사용한다.
- **주 4회 이상 실천하면 퀘스트 달성!**

---

## 퀘스트 3: 건강 관련 조언, AI에게 매일 받기

### 배경
개발자들은 장시간 앉아 있거나, 불규칙한 생활을 하게 되는 경우가 많습니다. AI에게 매일 건강 관련 조언을 받으면, 작은 습관부터 개선할 수 있는 계기가 됩니다.

### 목적
- 건강한 루틴을 만들기 위한 작은 실천을 유도한다.
- AI의 조언을 통해 생활 습관을 점검한다.

### 달성 기준
- 하루 한 번 AI에게 "오늘 나에게 도움이 될 건강 조언을 해줘"라고 요청한다.
- 받은 조언 중 하나를 실천하거나 기록한다.
- **주 4회 이상 실천하면 퀘스트 달성!**

<details>
  <summary>J304 김민우</summary> 
  <img width="965" height="637" alt="image" src="https://github.com/user-attachments/assets/c9f747ca-a6a6-4b2e-b909-28fc14f8fffa" />
  <img width="974" height="635" alt="image" src="https://github.com/user-attachments/assets/4c9aa319-71bc-4a20-8803-195ad5178208" />
  <img width="958" height="698" alt="image" src="https://github.com/user-attachments/assets/6a7de944-763e-49c4-bba0-ee5fd3e9857d" />
  <img width="985" height="527" alt="image" src="https://github.com/user-attachments/assets/18bcc259-964b-4b81-b736-878ea2104562" />

</details>

<details><summary>J177 이규태</summary>
  
  ## 퀘스트 3: 건강 관련 조언, AI에게 매일 받기
  > Q: 나는 개발자를 꿈꾸는 사람이야. 오늘 나에게 도움이 될 건강 조언을 해줘
  
  ### `8/4` ~ `8/7`
  > 개발자로서 오랜 시간 컴퓨터 앞에 앉아있는 일이 많을 텐데, 건강을 유지하는 게 정말 중요해. 특히, 앉아있는 시간이 길어질수록 신체에 부담이 가게 되니까, 몇 가지 팁을 주고 싶어.
  > ### 1. **자주 스트레칭하기**
  > * 한 번 앉으면 몇 시간씩 계속 앉아 있게 되잖아. 그러니까 적어도 1시간에 한 번은 일어나서 스트레칭을 하자. 특히 목, 어깨, 허리 부분을 자주 풀어주면 좋고, 손목이나 팔꿈치도 자주 풀어주는 게 좋아.
  > ### 2. **눈 건강을 지키기**
  > * 스크린을 계속 보면 눈이 피로해지고, 나중에는 눈 건강이 나빠질 수 있어. 20-20-20 규칙을 시도해 보자: 20분마다 20초 동안 20피트(약 6미터) 이상 떨어진 곳을 쳐다보기.
  > ### 3. **좋은 자세 유지하기**
  > * 의자와 책상이 잘 맞는지, 모니터가 눈높이에 맞는지 확인해봐. 팔꿈치가 직각이 되도록 하고, 의자에 앉을 때는 등받이를 잘 이용해서 허리가 굽지 않도록 하자.
  > ### 4. **물 자주 마시기**
  > * 개발을 하다 보면 물 마시는 걸 잊을 때가 많은데, 물은 집중력 향상에도 중요해. 커피나 에너지 음료에 의존하기보다는 물을 자주 마시고, 수분을 충분히 섭취하는 게 좋아.
  > ### 5. **규칙적인 운동**
  > * 짧은 시간이라도 운동을 하는 습관을 들이면 좋아. 매일 20-30분 정도의 가벼운 운동(산책, 자전거 타기 등)을 해주는 것만으로도 체력 유지에 큰 도움이 돼.
  > ### 6. **올바른 식습관**
  > * 건강한 음식을 고르고 규칙적으로 식사를 하는 게 중요해. 가공식품보다는 신선한 과일, 채소, 단백질 위주의 식사를 하도록 해. 개발하면서 계속 간식에 손이 가기 쉽지만, 영양가 있는 간식으로 선택하는 게 좋지.
  > 이 중에서 하나씩 실천해 보면 좀 더 건강하게 개발을 할 수 있을 거야. 지금 너는 어떤 작업을 하고 있거나, 건강 관련해서 고민이 있는 부분이 있을까?
  
  **자주 스트레칭하기**를 선택했습니다.
</details>

---

## 퀘스트 4: 번아웃 예방, AI에게 동기부여 멘트 받기

### 배경
지속적인 학습과 미션 수행은 때때로 번아웃을 유발할 수 있습니다. AI에게 동기부여 멘트를 받으면, 감정적으로 리프레시하고 다시 집중할 수 있는 힘을 얻을 수 있습니다.

### 목적
- 감정적 회복과 동기부여를 위한 루틴을 만든다.
- AI의 멘트를 통해 스스로를 격려한다.

### 달성 기준
- 하루 한 번 AI에게 "오늘 나에게 동기부여가 되는 멘트를 해줘"라고 요청한다.
- 받은 멘트를 기록하거나 공유한다.
- **주 4회 이상 실천하면 퀘스트 달성!**

---
# 퀘스트 수행 기록
### 1. J270 최민식
<details>
  <summary>J270 최민식</summary> 
  <img width="1013" height="475" alt="릴프1" src="https://github.com/user-attachments/assets/5d36efaf-7bbe-4a88-b10d-24f8caf9ed21" />

</details>

### 2. S034 제민우
#### 2.1 선택 이유
평소 변수명 짓기에 은근 많은 시간을 썼습니다. `5분, 10분만 고민해야지`가 10번 반복되면 50분에서 100분이라는 것을 깨달았습니다🥲.  
네이밍에 대한 고민은 좋은 고민이지만, 챌린지처럼 급할 때는 빨리 넘어갈 수 있어야 합니다.  
'만약 나만의 네이밍 패턴이 생긴다면 품질과 속도를 더 챙길 수 있겠다!' 는 생각에 해당 미션을 선택하게 되었습니다.


#### 2.2 수행 과정: Service? Manager? Provider? 무슨 차이일까?
Day18 미션을 진행하며 **채팅 관리 객체**와 **토큰 생성 객체**를 `Service`라는 이름으로 지었습니다.  

다음날 개선을 진행하며`'이 객체가 진짜 Service인가?'`, `'내가 봤던 Service들은 네트워크에서 데이터를 받아왔던 것 같은데?'`, `'Service 객체가 정확히 뭐지....????'` 라는 생각이 들었습니다.  

이번 기회에 자주 사용되는 접미사?들을 정리해보고자 지피티와 제미나이 선생님에게 물어보고 나름의 결론을 내렸습니다.

- 토큰 생성 객체: `TokenGenerator`
  - 저의 설계 상 토큰 생성 객체는 내부 상태 없이 단순히 토큰을 만들어냅니다.
  - 따라서 비즈니스 로직을 수행하지 않아 Service는 부적절하다고 생각했고, Generator가 더 적합하다고 판단했습니다.
- 채팅 관리 객체: `ChatService`
  - 채팅 관리 객체는 **현재 활성화 된 채팅** 이라는 상태를 가집니다.
  - 이 상태는 `private`으로 선언되어 있어, 서버는 **채팅 관련 서비스을 제공** 받고 있습니다.
  - 현재 구조에서는 서버가 주인공?이므로 서버 관점에서 결정을 내렸습니다.

그런데 정답이 없고 너무 어렵습니다. 정확히 나누기엔 기준이 모호한 것 같기도, 제 경험이 부족한 것 같기도 합니다😂.  
찾아볼 당시 새벽이라 잠도 오고... 시간도 부족했어서 레퍼런스 체크는 하지 못해 간단하게만 정리해두었습니다.  
(할루시네이션 주의!!)



<details>
<summary><h4>GPT의 생각</h4> (🔻<b>자세히보기</b>)</summary>

| 이름 | 언제 사용하는가? | 주요 특징 | 예시 |
| --- | --- | --- | --- |
| **Service**     | 💡 여러 객체를 조합하여 **비즈니스 로직**을 구현할 때 | - Usecase보다 세부 로직 단위 <br> - 외부 API, DB, Manager 등을 조합 | `PaymentService`, `AuthService`, `ChatService` |
| **Usecase**     | 💡 유저의 "행위" 단위로, **앱의 흐름**을 구현할 때 | - 유저 중심: "로그인하기", "주문하기" <br> - Service, Repository 등을 orchestration | `LoginUsecase`, `BuyProductUsecase` |
| **Manager**     | 💡 특정 **상태나 자원**을 직접 보관, 제어할 때    | - 내부에 상태를 가짐 (ex. 캐시, 세션, 리스트 등) <br> - 수명과 생명주기를 관리 | `SessionManager`, `CacheManager`, `AudioManager` |
| **Repository**  | 💡 DB나 파일 등 **영속성 저장소에 접근**할 때    | - DB의 CRUD 담당 <br> - 도메인과 저장소 사이의 추상화 | `UserRepository`, `ProductRepository` |
| **Provider**    | 💡 무언가를 **제공하는 책임**만 있을 때 (읽기 중심) | - 설정값, 리소스, 외부 데이터 제공 <br> - 상태나 복잡한 로직 없음 | `TokenProvider`, `ConfigProvider`, `LocaleProvider`    |
| **Generator**   | 💡 무언가를 **생성하는 책임**이 있을 때 (출력 중심) | - 입력 → 출력 생성 (랜덤값, 토큰, ID 등) <br> - 내부 상태 없음 (stateless) | `UUIDGenerator`, `TokenGenerator`, `PasswordGenerator` |
| **Handler**     | 💡 **이벤트, 요청, 메시지 등 처리** 시        | - 콜백이나 입력에 대한 분기 처리 <br> - `onXXX`, `handleXXX` 구조 많음 | `LoginRequestHandler`, `MessageHandler` |
| **Factory**     | 💡 객체 생성을 **조건에 따라 분기**할 때        | - 여러 구현체 중 하나 선택 <br> - 생성 로직을 추상화 | `ViewFactory`, `RepositoryFactory` |
| **Builder**     | 💡 복잡한 객체를 **단계적으로 구성**할 때        | - 불변 객체, 체이닝 등 <br> - `build()` 메서드로 완성 | `RequestBuilder`, `UIBuilder` |
| **Coordinator** | 💡 **화면 전환**이나 **흐름 제어**를 맡을 때    | - UIKit/SwiftUI의 화면 이동 제어 <br> - ViewController decoupling | `AppCoordinator`, `LoginCoordinator` |
| **Controller**  | 💡 **UI or 외부 요청**을 받아 처리할 때      | - View 로직 or API 입구 <br> - MVC의 Controller | `UserController`, `ShoppingController` |
| **Adapter**     | 💡 **인터페이스 변환**이 필요할 때            | - 외부 시스템 연결 <br> - 호환성 확보 목적 | `PaymentAdapter`, `LegacySystemAdapter` |

- Manager: 상태(state)를 보유하고 그것을 관리하는 컨트롤러 느낌.
- Service: 도메인 기능 하나의 작업 단위를 캡슐화한 객체. (주로 상태 없음)
</details>

<details>
<summary><h4>Gemini의 생각</h4> (🔻<b>자세히보기</b>)</summary>

사용자님의 지적대로, ChatManager는 activeSession이라는 상태를 보유하고 있으니 Manager에 가까워 보입니다. 그럼에도 ChatService라고 생각한 이유는 **'외부에서 바라보는 역할(Public Interface)'**과 '캡슐화' 에 더 중점을 두었기 때문입니다.

```swift
// 제가 구현한 코드입니다!
// ChatSession은 그룹 관련 정보(채팅 시작한 캠퍼, 그룹 아이디, 채팅의 최대 대화 수, 현재 채팅 수)를 정의하는 데이터 모델(구조체)입니다.

/// ChatService 프로토콜의 기본 구현체입니다.
final class DefaultChatService: ChatService {
    /// 현재 활성화된 채팅 세션을 그룹 ID를 키로 하여 관리합니다.
    private var activeSession: [Int: ChatSession] = [:]

    init() { }

    /// 새로운 채팅 세션을 시작합니다.
    func startSession(by camper: Camper, maxCount: Int) -> Result<Void, ChatError> { ... }

    /// 메시지를 보내고, 세션의 현재 메시지 카운트를 1 증가시킵니다.
    func sendMessage(from camper: Camper, message: String) -> Result<Void, ChatError> { ... }

    /// 현재 활성화된 채팅 세션을 종료(제거)합니다.
    func finishSession(by camper: Camper) -> Result<Void, ChatError> { ... }
}
```

1. 소비자 관점에서의 역할 (Consumer's Perspective)

ShoppingServer 입장에서 생각해 봅시다. 서버는 채팅 기능이 필요할 때, ChatManager의 내부 상태(activeSession)가 어떻게 돌아가는지 전혀 관심이 없습니다. 서버는 그저 "채팅 세션을 시작해 줘", "메시지를 보내줘" 와 같은 '서비스'를 요청하고 소비할 뿐입니다.

ShoppingServer는 ChatService에게 '채팅 서비스'를 요청합니다.

ProductService에게 '상품 서비스'를 요청합니다.

AuthService에게 '인증 서비스'를 요청합니다.

이처럼 ChatService라는 이름은 이 객체의 '목적'과 '역할'을 소비자 입장에서 가장 명확하게 설명해 줍니다.

2. 완전한 상태 캡슐화 (Strong Encapsulation)

ChatManager가 상태를 가지고 있는 것은 맞지만, 그 상태(activeSession)는 private으로 선언되어 외부에서는 절대 직접 접근할 수 없습니다. 모든 상태 변경은 startSession(), sendMessage() 같은 공개된 메서드(서비스)를 통해서만 가능합니다.

Manager라는 이름은 때로 상태를 외부에서도 조회하거나 일부 제어할 수 있다는 뉘앙스를 주기도 합니다.

하지만 이 객체는 자신의 상태를 완벽한 블랙박스처럼 숨기고 오직 '서비스'만을 제공하므로, Service라는 이름이 그 '행위'를 더 잘 표현합니다.

비유하자면, 우리는 은행 창구 직원에게 "송금해주세요"라는 서비스를 요청합니다. 그 직원이 내부적으로 어떤 장부(상태)를 어떻게 관리하는지는 알 필요가 없죠. 이 때 우리는 '은행원'을 '장부 관리자(Manager)'가 아닌 '금융 서비스 제공자(Service Provider)'로 인식하는 것과 같습니다.

#### 결론: Service vs Manager
구분	ChatService	ChatManager
관점	외부 소비자(Server)의 관점을 중시. "어떤 서비스를 제공하는가?"	내부 구현의 관점을 중시. "어떤 상태를 관리하는가?"
핵심	**행위(Behavior)**와 목적(Purpose)	**상태(State)**와 제어(Control)
장점	다른 서비스(ProductService 등)와 이름의 일관성을 맞추고, 역할을 명확히 한다.	상태를 가진다는 사실을 이름에 명시적으로 드러낸다.
두 이름 모두 틀리지 않았습니다. 이것이 소프트웨어 설계의 묘미입니다.

다만, 우리가 지향하는 프로토콜 기반의 느슨한 결합 구조에서는 객체의 내부 구현보다는 외부에서 바라보는 역할과 책임을 더 중요하게 생각하므로, ChatService가 이 설계 철학에 조금 더 잘 부합한다고 판단했습니다.

가장 중요한 것은 일관성입니다. 팀 내에서 "상태가 있으면 Manager, 없으면 Service"라고 규칙을 정했다면 ChatManager가 맞는 이름이 됩니다. 지금처럼 역할 중심으로 이름을 붙인다면 ChatService가 더 좋은 선택이 될 수 있습니다.

</details>

