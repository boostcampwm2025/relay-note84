# week2

## 토론기록

### 주제

지난 주 84팀의 주제와 비슷하게 개발자와 부스트캠프 커뮤니티 성장을 위해 AI 활용하기

페어 프로그래밍을 잘 할 수 있는 방법을 생각해보자

➡️ 개발자로서의 성장, 커뮤니티 능력 향상

### 미션

1. 코딩 컨벤션 맞추기
   - 내가 사용하던 포맷과 페어가 사용하던 포맷 두가지를 AI를 통해 효율적인 포맷팅 방법 찾기

2. 커밋 메시지 추천받기
   - 페어가 이해하기 쉽고, 작업 내용이 잘 담긴 커밋 메시지 추천받기

3. 스크럼 자료 요약
   - 음성인식 AI를 이용하여 스크럼 내용을 텍스트로 요약받기

4. 코드 리뷰 가이드라인 설정
   - 미션주제에 따라 AI가 리뷰 기준을 정해서 그 기준에 맞춰 피드백, 리뷰

### 달성기준

1. 컨벤션 수정 후 커밋하기
2. 본인이 생각한 커밋 메시지와 AI로 추천받은 커밋메시지 기록하기
3. 자료 요약본 생성
4. 가이드라인과 가이드에 맞춰 리뷰하기

# 2주차 69팀의 84팀의 퀘스트 클리어 전략

- 인당 최소 하나 이상의 퀘스트를 선택해서 수행
- 금요일 13시 취합하여 Week2.md 파일에 작성

## 미션 수행 결과

### J140
#### 수행한 미션

코드 리뷰 가이드라인 설정

#### 미션 진행 내용

사용한 프롬프트

```markdown
너는 이제부터 코드 리뷰 가이드라인을 설정해야해.
미션 주제에 따라 코드 리뷰 기준을 정해서 기준에 따라 코드 리뷰해줘.

미션 주제는 Git 프로그램 명령어 동작을 참고해 git init과 호환되는 명령을 만드는 거야
```

AI가 전달해준 코드 리뷰 가이드라인

```markdown
**1. 기능 명세 충족 여부
 .git/ 디렉토리 및 하위 구조 (objects/, refs/, HEAD)가 정확히 생성되었는가?

 HEAD 파일에 "ref: refs/heads/master" 가 정확히 쓰였는가?

 인자로 주어진 경로에 .git/ 디렉토리를 생성하는가?

 이미 Git 저장소가 존재하는 경우 적절한 예외 처리를 하는가?

2. 코드 구조 및 모듈화
 GitInitController, FileWriter, DirectoryCreator 등의 역할이 분리되어 있는가?

 단일 책임 원칙(SRP)에 부합하는가?

 명령어 실행 로직과 파일 시스템 작업이 적절히 추상화되었는가?

...**
```

#### 느낀점

- 기능 명세, 구조화, 에러 핸들링, 테스트 가능성 등을 각 항목별로 세분화해서 정리해주었습니다.
- AI 없이도 어느 정도 기준을 세워서 리뷰를 해볼 수는 있겠지만 AI의 도움을 받는다면 좀더 체계적이고 추가적인 가이드라인 인사이트를 얻을 수 있을 것 같습니다.

### J274
#### 수행한 미션

ai를 활용해 페어가 이해하기 쉽고, 작업 내용이 잘 담긴 커밋 메시지 추천받기

#### 미션 진행 내용

AI에게 수정 전 코드와 수정 후 코드를 제공하여 커밋 메시지 추천을 요청했습니다.

**진행 과정:**
1. 기존 코드(수정 전)와 리팩토링된 코드(수정 후)를 AI에게 제공
2. 변경사항을 분석하여 적절한 커밋 메시지를 추천해달라고 요청
3. AI가 코드 변경사항을 파악하고 명확하고 구체적인 커밋 메시지를 제안
4. 페어 프로그래밍 상황에서 협업자가 이해하기 쉬운 메시지 형태로 추천받음

**AI 활용 방법:**
- 코드 diff를 통해 정확한 변경사항 파악
- 기능 추가, 버그 수정, 리팩토링 등 변경 유형에 맞는 메시지 구조 제안
- 간결하면서도 구체적인 설명을 포함한 커밋 메시지 생성

**결과**

```bash
refactor: CommandExecutor 클래스 전면 개선

- 상세한 로깅 및 에러 처리 추가
- 모든 Git 명령어에 대한 파라미터 검증 구현
- 위험한 명령어 실행 전 안전성 검사 추가
- 타임아웃 지원 및 환경 검증 기능 구현
- 브랜치, 상태확인 등 Git 기본 명령어 지원 확대

refactor: StateCapture 클래스 전면 개선으로 포괄적인 Git 상태 추적 구현

- Git 참조 정보(HEAD, 브랜치, 태그, 원격) 수집 기능 추가
- reflog 파싱을 통한 Git 히스토리 추적 기능 구현
- 작업 디렉토리 파일 상태 재귀 스캔 개선
- 상태 간 상세 비교 분석 기능 강화 (추가/수정/삭제 감지)
- 에러 처리 및 로깅 시스템 개선


 feat: ObjectWriter 클래스로 Git Blob 객체 생성 기능 구현
    
    - 파일을 Git blob 객체로 변환 및 저장
    - SHA-1 해시 계산 및 Git 표준 디렉토리 구조 생성
    - zlib 압축을 통한 효율적인 저장소 관리
    - 중복 객체 감지로 저장소 최적화
    - Git 표준 형식 준수 (blob [크기]\0[내용])

    refactor: GitRepository를 포괄적인 Git 저장소 관리 시스템으로
 전면 개선
    
    - Git worktree 및 submodule 지원 (.git 파일 처리)
    - 크로스 플랫폼 호환 경로 처리 (Windows/Unix 모두 지원)
    - HEAD 파일 내용 검증 및 브랜치 정보 추출
    - 저장소 상태 요약 및 객체 개수 통계 기능
    - 필수 파일/디렉토리 존재 여부 엄격한 검증
    - 포괄적인 에러 처리 및 상세한 로깅 시스템
```

#### 느낀점

그동안 일관성 없는 커밋메세지를 작성해왔는데 ai를 활용해 커밋 메세지를 생성하니 일관성 있는 형식을 유지할 수 있었습니다
또, 여러 작업을 진행하느라 무엇을 수정하고 구현했는지 헷갈릴때가 많았는데, 개선된 점을 글로 정리해주어서 다른 사람이 커밋 메세지를 보고 코드 히스토리를 추적할 때에도 도움이 많이 될 것 같습니다!

### J048_김승호

#### 수행한 미션

- 커밋 메세지 추천받기

#### 미션 진행 내용

사용한 프롬프트
```
내가 작성한 git 프로젝트의 코드와 커밋 내역을 보고 commit이 필요한 시점과 내용을 제시해줘
```

AI가 전달해준 코드 리뷰 가이드라인
```
1. 핵심 기능 단위 구현 완성 시
새로운 기능(예: Object 파일 읽기/쓰기, 로그 비교 등)의 최소 동작 버전이 완성되어, 최소한의 테스트(직접 운영 또는 자동 테스트)를 통과한 순간에 커밋

예시:
	
	"feat: 블롭(blob) 오브젝트 직접 쓰기 기능 추가"
	
	"feat: LogHandler에 브랜치 로그 비교 기능 구현"
	
	2. 버그 수정 또는 동작 개선 완료 시
주요 버그에 대한 패치 또는 사소한 동작 최적화, 예외처리 보완 등 기능 단위로 문제를 해결한 뒤 커밋

예시:
	
	"fix: 로그 파싱시 브랜치명 미지정 오류 수정"
	
	"refactor: load 함수 코드 중복 제거"
	
3. 구조/리팩토링 작업 단위로
코드 구조/클래스 관계/폴더 구조 변경, 불필요한 의존성 분리, 대규모 함수 리팩토링이 완료될 때마다 커밋

예시:
	
	"refactor: LogHandler와 ObjectHandler 구조 분리"
	
	"chore: 테스트 코드 Mocha에서 Jest로 이관"
	
4. 테스트 케이스 추가 혹은 통과 시점
새로운 테스트 케이스를 추가했거나, 존재하는 테스트가 모두 통과하면 이를 별도 이력으로 관리

예시:
	
	"test: object 파일 write 테스트케이스 추가 및 통과"
	
5. 프로그램 외부 인터페이스/사용법 변화 시
CLI 명령어 추가/변경, 옵션 구조/이벤트 버스 개선 등 “사용자 입장에서의 변화”가 있을 때

예시:
	
	"feat: CLI 명령어 파서 및 이벤트 핸들링 개선"
	
6. 배포/버전 단위 또는 주요 단계 마무리 시
실험/테스트 완료, 주요 milestone(기능 프로토타입 완성, 1차 품질 보장 등) 기준

예시:
	
	"release: 내부 git 데이터 조작 기본모듈 1.0.0 릴리즈"
	
7. 짧은 작업이라도 독립적 논리 단위로 쪼개서
단일 작업이 너무 크거나 복합적일 경우, 핵심 논리별로 세분화하여 작은 단위의 커밋을 선호

(→ 나중에 히스토리 탐색·문제추적이 훨씬 쉬움)

예시:
	
	"feat: SHA-1 커스텀 해시 함수 도입"
	
	"fix: 커밋시 타임스탬프 포맷 버그 수정"

구체적 주기・패턴 권고
MINOR 기준: 1~3시간/작업 논리 단위마다, 혹은 '한 파일/함수/핵심기능'별 최소 1커밋

MAJOR 기준: 주요 요구사항/마일스톤 단위별로 추가 커밋 혹은 태그 생성

자동화: 테스트 또는 빌드가 통과할 때, CI/CD 파이프라인의 단계를 커밋 트리거로 활용 가능
```
#### 느낀점

- 프로그램의 목적이나 지향하는 형태에 따라서 설계가 달라지고, 커밋을 언제마다 진행해야할지 고민이었는데, 하나의 가이드가 되었던 것 같다.
- 내용은 기존의 git commit 규칙으로 알려진 내용과 비슷해서 참신한 점은 없었지만 예시의 내용이 내가 작성했던 프로젝트의 내용이라서 이해하기 좋았다.

### J271_최재영

#### 수행한 미션

- 커밋 메시지 추천받기

#### 미션 진행 내용

- 사용한 프롬프트

```
"너는 지금 git 강의를 막 마친 강사야. 수강생들에게 git 명령어들의 동작 원리를 이해하기 위해 구현을 시켰어. init, add, commit, log, status 명령어들을 직접 구현해보고 구현할 때마다 작성할 커밋 메시지를 다른 사람들이 보기에 이해하기 편하도록 추천해줘"
```

AI가 전달해준 코드 리뷰 가이드라인

```
1. init (저장소 초기화)

feat: Git 저장소 초기화 메서드 구현
- .git 디렉토리 및 하위 구조(objects, refs 등) 생성
- 기본 HEAD 파일 작성하여 master 브랜치 가리키도록 설정

에러 처리 추가 시
fix: init 시 이미 .git 폴더가 존재할 때 에러 반환
- 중복 초기화 방지 로직 추가
- 사용자에게 명확한 에러 메시지 제공

2. add (파일 스테이징)

feat: 파일 스테이징 메서드 구현
- 지정된 파일 해시 생성 후 .git/index에 기록
- 기존 변경 내역과 비교해 수정/추가 구분

다중 파일 처리 시
feat: 여러 파일을 한 번에 스테이징하도록 기능 확장
- add 메서드에서 파일 배열 입력 처리
- 루프 돌며 인덱스 업데이트 및 중복 제거

3. commit (커밋 생성)
feat: 커밋 생성 메서드 구현
- 현재 index 상태 기반으로 트리 객체 생성
- 부모 커밋 참조 및 커밋 메시지 포함한 commit 객체 작성
- HEAD와 refs 업데이트

커밋 메시지 검증 추가 시
fix: 빈 커밋 메시지 입력 시 에러 처리
- commit 메서드에서 메시지 유효성 검증
- 테스트 케이스 추가로 안정성 확보

4. log (커밋 로그 조회)
feat: 커밋 로그 조회 메서드 구현
- HEAD에서 부모 커밋을 따라가며 로그 출력
- 커밋 해시, 메시지, 타임스탬프 형식 지정

포맷 개선 시
refactor: log 출력 포맷 개선
- 해시 앞 7자리만 표시하도록 변경
- 날짜 및 메시지를 보기 쉽게 줄바꿈 처리

5. status (작업 상태 확인)

feat: 작업 상태 확인 메서드 구현
- index와 워킹 디렉토리 비교해 변경 파일 목록 출력
- untracked, staged, modified 상태 구분 표시

최적화 시
refactor: status 출력 속도 개선
- 변경 감지 시 해시 비교 방식으로 최적화
- 대용량 파일 처리 시 성능 향상

## 커밋 메시지 작성 패턴 요약

첫 구현 시: feat: <명령어> 메서드 구현

로직 개선/분리 시: refactor: <명령어> 출력/처리 로직 개선

에러 처리 시: fix: <명령어> 잘못된 입력 시 예외 처리

출력/UX 개선 시: style: <명령어> 출력 포맷 수정
```

#### 느낀점

- 체크포인트를 기능 단위로 나누고, 기능을 구현할 때마다 commit하는 방식을 네부캠에서 지향하기 때문에 지키려고 노력하고 있지만, 구현을 하다보면 자주 까먹기도 하고 커밋 메시지를 어떤 식으로 작성할지 시간이 오래 걸리는 순간이 많았습니다. 이를 해결하기 위해 퀘스트 중에서 커밋 메시지 추천받기를 선택했고, 코드 리팩토링이나 구현 도움 이외에도 많은 도움을 받을 수 있다는 것을 느꼈습니다.
- AI를 이용해 커밋 메시지를 추천 받으니 똑같이 작성할 수는 없지만 개발 외적인 부분에서 더 효율적으로 시간을 분배할 수 있게 되었습니다. .git 폴더를 실수로 삭제하는 경우가 발생하여 한 번에 commit하느라 실제로 모든 부분에 사용하지는 못했지만 앞으로는 오래 고민할 것 같은 상황이 온다면 AI를 활용해 좀 더 효율적으로 해결할 수 있다는 것을 알았습니다.
